#第10章 内存
内存是装载程序运行的介质，也是程序进行各种运算和表达的场所。

##10.1 程序的内存布局
在32位系统里，内存空间拥有4GB的寻址能力。相对于16位时代i386的短地址加段内偏移的寻址模式，如今的应用程序可以直接使用32位的地址进行寻址，这被称为平坦的内存模型。

尽管当前的内存空间号称是平坦的，但实际上内存仍然在不同的地址区间上有着不同的地位，例如，大多数操作系统会将4GB的内存空间上的一部分挪给内核使用，应用程序无法直接访问这一段内存，这一部分内存地址被称为内核空间。Windows在默认情况下会将高地址的2GB空间分配给内核，而Linux默认情况下将高地址的1GB空间分配给内核。

用户使用的剩下2GB或3GB的内存空间称为用户空间。在用户空间里，有许多地址区间有特殊的地位：

- 栈： 栈用于维护函数调用的上下文，离开了栈函数调用就没法实现。栈通常在用户空间的最高地址处分配。
- 堆：堆是用来容纳应用程序动态分配的内存区域，当程序使用malloc或new分配内存时，得到的内存来自堆里。堆通常存在于栈的下方，在某些时候，堆也可能没有固定统一的存储区域。堆一般比栈大很多。
- 可执行文件映像：这里存储着可执行文件在内存里的映像，由装载器在装载时将可执行文件的内存读取或映射到这里。
- 保留区：保留区并不是一个单一的内存区域，而是对内存中受到保护而禁止访问的内存区域的总称。例如，大多数操作系统里，极小的地址通常都是不允许访问的，如NULL。

![](../images/10.01.png)

动态链接库映射区用于映射装载的动态链接库。在Linux下，如果可执行文件依赖其他共享库，那么系统就会为它在从0x40000000开始的地址分配相应的空间，并将共享库载入到该空间。

> 段错误是怎么回事？
>
> 这是典型的非法指针解引用造成的错误。当指针指向一个不允许读或写的内存地址，而程序却试图利用指针来读或写该地址的时候，就会出现这个错误。
> 在Linux或Windows的内存布局中，有些地址是始终不能读写的，例如0地址。还有些地址是一开始不允许读写，应用程序必须事先请求获取这些地址的读写权，或者某些地址一开始并没有映射到实际的物理内存，应用程序必须事先请求将这些地址映射到实际的物理地址，之后才能够自由地读写这片内存。当一个指针指向这些区域的时候，对它指向的内存进行读写就会引发错误。造成这样的最普遍的原因有两种：
>
> 1. 程序员将指针初始化为NULL，之后却没有给它一个合理的值就开始使用指针。
>
> 2. 程序员没有初始化栈上的指针，指针的值一般会是随机数，之后就直接开始使用指针。（野指针）

##10.2 栈与调用惯例
###10.2.1 什么是栈
在经典的计算机科学中，栈被定义为一个特殊的容器，用户可以将数据压入栈中，也可以将已经压入栈中的数据弹出，但栈这个容器必须遵守一条规则：先入栈的数据后出栈（FIFO）。

在计算机系统中，栈则是一个具有以上属性的动态内存区域。程序可以将数据压入栈中，也可以将数据从栈顶弹出。压栈操作使得栈增大，而弹出操作使栈减小。

在经典的操作系统里，栈总是向下增长的。在i386下，栈顶由称为esp的寄存器进行定位。压栈的操作使栈顶的地址减小，弹出的操作使栈顶地址增大。

栈在程序运行中具有举足轻重的地位。最重要的，栈保存了一个函数调用所需要的维护信息，这常常被称为堆栈帧（Stack Frame）或活动记录（Active Record）。堆栈帧一般包括如下几方面内容：

- 函数的返回地址和参数。
- 临时变量：包括函数的非静态局部变量以及编译器自动生成的其他临时变量。
- 保存的上下文：包括在函数调用前后需要保持不变的寄存器。

在i386中，一个函数的活动记录用ebp和esp这两个寄存器划定范围。esp寄存器始终指向栈的顶部，同时也就指向了当前函数的活动记录的顶部。而相对的，ebp寄存器指向了函数活动记录的一个固定位置，ebp寄存器又被称为帧指针（Frame Pointer）。一个很常见的活动记录实例如下所示：

![](../images/10.02.png)

在参数之后的数据（包括参数）即是当前函数的活动记录，ebp固定在图中所示的位置，不随这个函数的执行而变化，相反地，esp始终指向栈顶，因此随着函数的执行，esp会不断变化。固定不变的ebp可以用来定位函数活动记录的各个数据。在ebp之前首先是这个函数的返回地址，它的地址是ebp-4，再往前是压入栈中的参数，它们的地址分别是ebp-8、ebp-12等，视参数数量和大小而定。ebp所直接指向的数据是调用该函数前ebp的值，这样在函数返回的时候，ebp可以通过读取这个值恢复到调用前的值。之所以函数的活动记录会形成这样的结构，是因为函数调用本身是如此书写的：一个i386下的函数总是这样调用的：

- 把所有或一部分参数压入栈中，如果有其它参数没有入栈，那么使用某些特定的寄存器传递。
- 把当前指令的下一个指令的地址压入栈中。
- 跳转到函数体执行。

其中第2步和第3步由指令call一起执行。跳转到函数体之后即开始执行函数，而i386函数体的“标准”开头是这样的（但也可以不一样）：

- push ebp：把ebp压入栈中（称为old ebp）。
- mov ebp, esp：ebp = esp（这时ebp指向栈顶，而此时栈顶就是old ebp）。
- 【可选】sub esp, xxx：在栈上分配xxx字节的临时空间。
- 【可选】push xxx：如有必要，保存名为xxx寄存器（可重复多个）。

把ebp压入栈中，是为了在函数返回的时候便于恢复以前的ebp值。而之所以可能要保存一些寄存器，在于编译器可能要求某些寄存器在调用前后保持不变，那么函数就可以在调用开始时将这些寄存器的值压入栈中，在结束后再取出。函数返回则正好相反：

- 【可选】pop xxx：如有必要，恢复保存过的寄存器（可重复多个）。
- mov esp, ebp：恢复esp同时回收局部变量空间。
- pop ebp：从栈中恢复保存的ebp的值。
- ret：从栈中取得返回地址，并跳转到该位置。

###10.2.2 调用惯例
